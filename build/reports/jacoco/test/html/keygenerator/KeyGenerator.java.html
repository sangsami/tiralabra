<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tiralabra</a> &gt; <a href="index.source.html" class="el_package">keygenerator</a> &gt; <span class="el_source">KeyGenerator.java</span></div><h1>KeyGenerator.java</h1><pre class="source lang-java linenums">package keygenerator;

/**
 *
 * @author samidinh
 */
import java.util.Random;
import java.math.BigInteger;
import java.util.List;
/**
 *
 * @author samidinh
 */
public class KeyGenerator {
    /** Array for public key. */
    private BigInteger[] publicKey;
    /** Array for private key. */
    private BigInteger[] privateKey;
    /** Array size for returnable key array. */
    private static final int ARRSIZE = 3;
    /** Times to loop Miller-Rabin primality test. */
    private static final int TESTTIMES = 128;
    
<span class="fc" id="L24">    public KeyGenerator() {</span>
<span class="fc" id="L25">        this.publicKey = new BigInteger[2];</span>
<span class="fc" id="L26">        this.privateKey = new BigInteger[2];</span>
<span class="fc" id="L27">    }</span>
    
    /**
     * Creates public and private keys for encryption from generated primes.
     */
    public void createKeys(int bitLength) {
<span class="fc" id="L33">        BigInteger p = generatePrime(bitLength, true);</span>
<span class="fc" id="L34">        BigInteger q = generatePrime(bitLength, true);</span>
        
        // RSA modulus
<span class="fc" id="L37">        BigInteger n = p.multiply(q);</span>
<span class="fc" id="L38">        System.out.println(&quot;Modulus n created...&quot;);</span>
<span class="fc" id="L39">        BigInteger pMinus = p.subtract(BigInteger.ONE);</span>
<span class="fc" id="L40">        BigInteger qMinus = q.subtract(BigInteger.ONE);</span>
        
        // Carmichael's totient
<span class="fc" id="L43">        BigInteger totient = pMinus</span>
<span class="fc" id="L44">                .divide(pMinus.gcd(qMinus))</span>
<span class="fc" id="L45">                .multiply(qMinus)</span>
<span class="fc" id="L46">                .abs(); //lcm(n)</span>
                
<span class="fc" id="L48">        BigInteger e = BigInteger.TWO;</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">        while (!e.gcd(totient).equals(BigInteger.ONE)) {</span>
            do {
<span class="fc" id="L51">                e = generatePrimeCandidate(totient.bitLength(), false); </span>
            } 
<span class="fc bfc" id="L53" title="All 2 branches covered.">            while (e.compareTo(totient) &gt;= 0);</span>
        }
<span class="fc" id="L55">        System.out.println(&quot;Public key e created...&quot;);</span>
<span class="fc" id="L56">        BigInteger d = modMultipInv(e, totient);</span>
<span class="fc" id="L57">        System.out.println(&quot;Private key d created...&quot;);</span>

<span class="fc" id="L59">        this.publicKey[0] = n;</span>
<span class="fc" id="L60">        this.publicKey[1] = e;</span>
<span class="fc" id="L61">        this.privateKey[0] = n;</span>
<span class="fc" id="L62">        this.privateKey[1] = d;</span>
<span class="fc" id="L63">    }</span>
    /**
     * Returns public key.
     * @return BigInteger[]
     */
    public BigInteger[] getPublicKey() {
<span class="fc" id="L69">        return this.publicKey;</span>
    }
    /**
     * Returns private key.
     * @return BigInteger[]
     */
    public BigInteger[] getPrivateKey() {
<span class="fc" id="L76">        return this.privateKey;</span>
    }
    
    public void setKeys(List&lt;String&gt; data) {
<span class="fc" id="L80">        this.publicKey[0] = new BigInteger(data.get(0)</span>
<span class="fc" id="L81">                .replace(&quot;\n&quot;, &quot;&quot;)</span>
<span class="fc" id="L82">                .replace(&quot;\r&quot;, &quot;&quot;));</span>
<span class="fc" id="L83">        this.publicKey[1] = new BigInteger(data.get(1)</span>
<span class="fc" id="L84">                .replace(&quot;\n&quot;, &quot;&quot;)</span>
<span class="fc" id="L85">                .replace(&quot;\r&quot;, &quot;&quot;));</span>
<span class="fc" id="L86">        this.privateKey[0] = new BigInteger(data.get(0)</span>
<span class="fc" id="L87">                .replace(&quot;\n&quot;, &quot;&quot;)</span>
<span class="fc" id="L88">                .replace(&quot;\r&quot;, &quot;&quot;));</span>
<span class="fc" id="L89">        this.privateKey[1] = new BigInteger(data.get(2)</span>
<span class="fc" id="L90">                .replace(&quot;\n&quot;, &quot;&quot;)</span>
<span class="fc" id="L91">                .replace(&quot;\r&quot;, &quot;&quot;));</span>
<span class="fc" id="L92">    }</span>
    /**
     * Extended euclidean algorithm.
     * @param e publicKey.
     * @param n RSA modulus.
     * @return modular multiplicative inverse in BigInteger.
     */
    private BigInteger modMultipInv(BigInteger e, BigInteger n) {
        // Swap the numbers, if compared one bigger
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (e.compareTo(n) &gt; 0) {</span>
<span class="nc" id="L102">            BigInteger temp = n;</span>
<span class="nc" id="L103">            n = e;</span>
<span class="nc" id="L104">            e = temp;</span>
        } 
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (e.compareTo(BigInteger.ONE) == 0) {</span>
<span class="fc" id="L107">            return BigInteger.ONE;</span>
        } 
<span class="fc" id="L109">        BigInteger d = BigInteger.ONE</span>
<span class="fc" id="L110">                .add(n.multiply(e.subtract(modMultipInv(n.mod(e), e))))</span>
<span class="fc" id="L111">                .divide(e);</span>
<span class="fc" id="L112">        return d;</span>
    }
    /**
     * Generates a random BigInteger of n bit length.
     * @param n bit length of the generated random BigInteger.
     * @param shift shifts the lower bit length bound to n-1 if true.
     * @return BigInteger of n bit length.
     */
    private BigInteger generatePrimeCandidate(int n, boolean shift) {
<span class="fc" id="L121">        BigInteger candidate = new BigInteger(n, new Random());</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (shift) {</span>
<span class="fc" id="L123">            candidate = candidate.setBit(0);</span>
        }
<span class="fc" id="L125">        return candidate;</span>
    }
    /**
     * Generates a prime number.
     * @param n bit length of the generated random BigInteger.
     * @param shift shifts the lower bit length bound to n-1 if true.
     * @return BigInteger prime number of n bit length.
     */
    private BigInteger generatePrime(int n, boolean shift) {
<span class="fc" id="L134">        BigInteger prime = BigInteger.TWO;</span>
        
<span class="fc bfc" id="L136" title="All 2 branches covered.">        while (!isPrime(prime, TESTTIMES)) {</span>
<span class="fc" id="L137">            prime = generatePrimeCandidate(n, true);</span>
<span class="fc" id="L138">        } return prime;</span>
    }
    /**
     * Test if candidate is divisible by first 100 primes.
     * @param candidate prime number candidate.
     * @return Boolean value if given number passes all tests.
     */
    private Boolean smallPrimesTest(BigInteger candidate) {
<span class="fc" id="L146">        String[] primes</span>
                = {&quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;, &quot;11&quot;, &quot;13&quot;, &quot;17&quot;, &quot;19&quot;, &quot;23&quot;, &quot;29&quot;, &quot;31&quot;,
                    &quot;37&quot;, &quot;41&quot;, &quot;43&quot;, &quot;47&quot;, &quot;53&quot;, &quot;59&quot;, &quot;61&quot;, &quot;67&quot;, &quot;71&quot;, &quot;73&quot;,
                    &quot;79&quot;, &quot;83&quot;, &quot;89&quot;, &quot;97&quot;, &quot;101&quot;, &quot;103&quot;, &quot;107&quot;, &quot;109&quot;, &quot;113&quot;,
                    &quot;127&quot;, &quot;131&quot;, &quot;137&quot;, &quot;139&quot;, &quot;149&quot;, &quot;151&quot;, &quot;157&quot;, &quot;163&quot;,
                    &quot;167&quot;, &quot;173&quot;, &quot;179&quot;, &quot;181&quot;, &quot;191&quot;, &quot;193&quot;, &quot;197&quot;, &quot;199&quot;,
                    &quot;211&quot;, &quot;223&quot;, &quot;227&quot;, &quot;229&quot;, &quot;233&quot;, &quot;239&quot;, &quot;241&quot;, &quot;251&quot;,
                    &quot;257&quot;, &quot;263&quot;, &quot;269&quot;, &quot;271&quot;, &quot;277&quot;, &quot;281&quot;, &quot;283&quot;, &quot;293&quot;,
                    &quot;307&quot;, &quot;311&quot;, &quot;313&quot;, &quot;317&quot;, &quot;331&quot;, &quot;337&quot;, &quot;347&quot;, &quot;349&quot;,
                    &quot;353&quot;, &quot;359&quot;, &quot;367&quot;, &quot;373&quot;, &quot;379&quot;, &quot;383&quot;, &quot;389&quot;, &quot;397&quot;,
                    &quot;401&quot;, &quot;409&quot;, &quot;419&quot;, &quot;421&quot;, &quot;431&quot;, &quot;433&quot;, &quot;439&quot;, &quot;443&quot;,
                    &quot;449&quot;, &quot;457&quot;, &quot;461&quot;, &quot;463&quot;, &quot;467&quot;, &quot;479&quot;, &quot;487&quot;, &quot;491&quot;,
                    &quot;499&quot;, &quot;503&quot;, &quot;509&quot;, &quot;521&quot;, &quot;523&quot;, &quot;541&quot;
                };

<span class="fc bfc" id="L161" title="All 2 branches covered.">        for (String prime: primes) {</span>
<span class="fc" id="L162">            if (candidate.mod(new BigInteger(prime))</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                    .compareTo(BigInteger.ZERO) == 0) {</span>
<span class="fc" id="L164">                return false;</span>
            }
        }
<span class="fc" id="L167">        return true;</span>
    }
    /**
     * Repeats Miller-Rabin test n times.
     * @param candidate prime number candidate to be tested.
     * @param n times to repeat test.
     * @return Boolean value if given number passes all tests.
     */
    private Boolean millerRabinRepeater(BigInteger candidate, int n) {
        // Miller-Rabin primality test, will be moved as own method soon
<span class="fc" id="L177">        BigInteger d = candidate.subtract(BigInteger.ONE);</span>
        
<span class="fc bfc" id="L179" title="All 2 branches covered.">        while (d.mod(BigInteger.TWO).equals(BigInteger.ZERO)) {</span>
<span class="fc" id="L180">            d = d.shiftRight(1);</span>
        }
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (!millerRabinTest(d, candidate)) {</span>
<span class="fc" id="L184">                return false;</span>
            }
        }
<span class="fc" id="L187">        return true;</span>
    }
    /**
     * Miller-Rabin primality test.
     * @param d exponent for modular arithmetics.
     * @param candidate prime candidate and modulus for modular arithmetics.
     * @return Boolean value if given number passes all tests.
     */
    private Boolean millerRabinTest(BigInteger d, BigInteger candidate) {
        BigInteger a;
<span class="fc" id="L197">        Random rand = new Random();</span>
        do {
<span class="fc" id="L199">            a = new BigInteger(candidate.bitLength(), rand); </span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            } while (a.compareTo(candidate.subtract(BigInteger.TWO)) &gt;= 0);</span>
            
<span class="fc" id="L202">        BigInteger x = a.modPow(d, candidate);</span>
            
<span class="fc bfc" id="L204" title="All 2 branches covered.">        while (d.compareTo(candidate.subtract(BigInteger.ONE)) != 0) {</span>
<span class="fc" id="L205">            x = (x.multiply(x)).mod(candidate);</span>
<span class="fc" id="L206">            d = d.shiftLeft(1);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (x.compareTo(BigInteger.ONE) == 0) {</span>
<span class="fc" id="L208">                return false;</span>
            }
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (x.compareTo(candidate.subtract(BigInteger.ONE)) == 0) {</span>
<span class="fc" id="L211">                return true;</span>
            }
        }
<span class="fc" id="L214">        return false;</span>
    }
    /**
     * Checks if given random BigInteger is a probable prime number.
     * @param candidate random BigInteger that will be tested.
     * @param n amount of times Miller-Rabin test to be run.
     * @return Boolean value is given BigInteger could be prime.
     */
    private Boolean isPrime(BigInteger candidate, int n) {
        // Not a prime is divisible by 2
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (candidate.mod(BigInteger.TWO).equals(BigInteger.ZERO)) {</span>
<span class="fc" id="L225">            return false;</span>
        }
        
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (!smallPrimesTest(candidate)) {</span>
<span class="fc" id="L229">            return false;</span>
        }
        
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (!millerRabinRepeater(candidate, n)) {</span>
<span class="fc" id="L233">            return false;</span>
        }
<span class="fc" id="L235">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>